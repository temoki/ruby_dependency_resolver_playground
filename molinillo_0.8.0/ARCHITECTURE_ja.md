# Molinilloアーキテクチャ

最上位レベルでは、Molinilloは依存関係解決アルゴリズムです。
`Resolver`に依存関係のリストと「ロック」された`DependencyGraph`を渡すと、結果として依存関係グラフが得られます。
しかし、依存関係のリストが適切に解決されることを保証するためには、単に依存関係のリストを順番に辿って、それぞれとその依存関係を順次有効化するよりも賢いアルゴリズムが必要です。

## バックトラッキング

Molinilloの中核には、[前進チェック](http://en.wikipedia.org/wiki/Look-ahead_(backtracking))を伴う[バックトラッキング](http://en.wikipedia.org/wiki/Backtracking)アルゴリズムがあります。
本質的に、解決プロセスはスタック内で2つのタイプの状態（依存関係と可能性）を追跡します。
このスタックが空になった場合、解決は不可能でした。
依存関係ごとに新しい状態がスタックにプッシュされ、依存関係が正常に「有効化」されるたびに、その有効化を表す新しい状態がスタックにプッシュされます。
このスタックベースのアプローチが使用される理由は、バックトラッキング（*巻き戻し*とも呼ばれる）がスタックから状態をポップするだけの簡単な操作になるからです。

### ウォークスルー

1. クライアントは`SpecificationProvider`と`UI`を使って`Resolver`を初期化する
2. クライアントはユーザーが要求した依存関係の配列とオプションの「ロック」された`DependencyGraph`を使って`resolve`を呼び出す
3. `Resolver`はこれら4つのユーザー指定パラメータで新しい`Resolution`を作成し、その`resolve`を呼び出す
4. `Resolution`は`initial_state`を作成し、ユーザーが要求した依存関係を取得して`DependencyState`に配置する
  - 状態を作成する過程で、`SpecificationProvider`に依存関係をソートし、`initial_requirement`のすべての`possibilities`を（依存関係が`locked`されているかどうかを考慮して）返すよう求められる。これらの可能性は`PossibilitySet`にグループ化され、各セットは同じサブ依存関係要件を共有し、連続している依存関係のバージョンのグループを表す
  - これらすべての要件が`root_vertices`を指す`DependencyGraph`が作成される
5. 解決プロセスは、処理する現在の`state`が存在し、現在の状態に処理すべき要件が残っている限り継続するメインループに入る
6. クライアントが進行状況を報告できるように`UI#indicate_progress`が呼び出される
7. 現在の状態が`DependencyState`の場合、その依存関係の`PossibilitySet`をカプセル化する`PossibilityState`をポップオフさせる
8. スタックの最上位の状態を処理する
9. 状態に空でない`PossibilitySet`がある場合、それを`attempt_to_activate`する（#11にジャンプ）
10. 状態に空でない`PossibilitySet`がない場合、状態が`PossibilityState`であれば`create_conflict`し、その後`unwind_for_conflict`する
  - `create_conflict`は、指定された依存関係のすべての要件の詳細を含む`Conflict`オブジェクトを構築し、依存関係の名前でインデックス化された`state`に格納されている競合のハッシュに追加する
  - `unwind_for_conflict`は`state`のすべての競合をループし、その競合を回避できる可能性のある状態を見つけて巻き戻す。そのような状態が存在しない場合、VersionConflictエラーを発生させる。そうでなければ、現在の競合を回避する可能性のある最新の状態を取得し、それに巻き戻す（#6へ）
11. この状態の`requirement`が関連する依存関係について、`activated`依存関係グラフに既存の頂点があるかチェックする
12. この状態の`requirement`が関連する依存関係について`activated`依存関係グラフに既存の頂点がない場合、`activate_new_spec`を実行する。これは`activated`依存関係グラフに新しい頂点を作成し、そのペイロードを可能性の`PossibilitySet`に設定する。また、今有効化された`PossibilitySet`の独自の依存関係で新しい`DependencyState`をプッシュする。#6へ
13. 依存関係に既存の`activated`頂点がある場合、`attempt_to_filter_existing_spec`を実行する
  - これは既存の頂点の`PossibilitySet`の内容を現在の状態の`requirement`でフィルタリングする
  - `PossibilitySet`内に可能性が残っている場合、有効化された頂点のペイロードを新しいフィルタリングされた状態で更新し、新しい`DependencyState`をプッシュする
  - フィルタリング後に`PossibilitySet`内に可能性が残らない場合、または現在の状態の`PossibilitySet`が既存の頂点の`PossibilitySet`とは異なるサブ依存関係要件のセットを持っていた場合、`create_conflict`と`unwind_for_conflict`を実行し、競合を生成しない可能性のある最後の`DependencyState`に戻る。#6へ
15. 処理すべき要件がなくなったら、最上位状態の依存関係グラフで終了する
16. この解決で許可されたバージョンのペイロード（つまり`PossibilitySet`）を持つ各頂点について、単一の特定のバージョンを選択する

### 最適な巻き戻し

バックトラッキングアルゴリズムが正確であるだけでなく効率的であるためには、
競合が発生した後に効率的に巻き戻す必要があります。巻き戻しすぎると有効な解決を見逃してしまいます - 一度DependencyStateを通り過ぎて巻き戻すと、二度とそこに到達できません。巻き戻しが少なすぎると解決が非常に遅くなります - 同じ競合を繰り返し発生させ、それを回避するブランチに到達する前に多くの不要な反復を処理することになります。

最適な量を巻き戻すために、現在の競合と、現在の状態を決定したすべての
以前の巻き戻しを考慮します。

1. まず、現在の競合を次のように考慮します：
  - 競合を引き起こす要件の最も早い（最も低いインデックス）セットを見つける。非拘束要件は無視できます。それらを削除しても現在の競合は解決されないからです
  - 各拘束要件について、要件を緩和するすべての代替可能性を見つける：
    - 要件のDependencyStateは、他のすべての要件を満たす代替可能性を持つ可能性がある
    - 要件の親は、要件の存在を防ぐ代替可能性を持つ可能性がある
    - 要件の親の親は、親、したがって要件の存在を防ぐ代替可能性を持つ可能性がある
    - 等々
  - 上記のすべての可能性を配列にグループ化し、最も高いインデックス（つまり、最小の巻き戻し）を持つものを候補の巻き戻しとして選択する
2. 次に、実行されなかった以前の巻き戻し（代わりに異なる、より小さな巻き戻しが選択されたため）を考慮します：
  - (1)で見つかった最高インデックスよりも遠くに巻き戻すであろう、以前に使用されなかった巻き戻しを無視する
  - 残りの使用されなかった巻き戻しについて、巻き戻しが現在の競合に遭遇することを防ぐ可能性があるかチェックする。これが可能であるためには、巻き戻しが現在の競合の要件ツリー内の状態の1つへの巻き戻しを支持して拒否されている必要がある
  - そのような巻き戻しが存在する場合、(1)で見つかったものの代わりに最も高いインデックス（最小の巻き戻し）を持つものを使用する
3a. (1)と(2)で可能な巻き戻しが見つからなかった場合、解決が不可能であるとしてVersionConflictエラーを発生させる
3b. 巻き戻し先の状態をフィルタリングして、競合を引き起こすことがわかっている可能性を削除する。このフィルタリングを行う際は、選択された状態へのすべての可能な巻き戻し（異なる競合に対する以前の使用されなかった巻き戻しから蓄積された複数の巻き戻しがある可能性がある）を考慮する - それらすべての競合を確実に引き起こす可能性のみを、解決の可能性がないものとしてフィルタリングできる
4. 使用されなかった巻き戻しのリストを更新する：
  - 現在の競合に対するすべての可能な巻き戻しを追加する
  - 選択されたものよりも低いインデックスを持っていたためだけに拒否された考慮された巻き戻しの`requirements_unwound_to_instead`属性を更新する
  - 選択された巻き戻し以上の状態へのすべての巻き戻しを削除する
5. メインループの#6へ

## Specification Provider

`SpecificationProvider`モジュールは、クライアントライブラリとMolinilloとの重要な統合ポイントの基盤を形成します。
そのメソッドは、クライアントのドメイン固有モデルオブジェクトをリゾルバーが理解する概念に変換します：

- ネストされた依存関係
- 名前
- 要件の満足
- 仕様の検索（内部的には`possibilities`として知られる）
- 依存関係のソート（合理的なリゾルバーパフォーマンスのため）
